//  ***Set Enviroment Variables***
//  LANSWEEPER_API_URL
//  LANSWEEPER_API_TOKEN
//  APP_PORT
//  ATLASSIAN_API_TOKEN
//  ATLASSIAN_EMAIL
//  ATLASSIAN_URL
require('dotenv').config();

const express = require('express');
const bodyParser = require('body-parser');
const axios = require("axios");
const app = express();
const port = 8080;
var vulnerabilities = [];
var assets = []

//download cirtical vulnerabilities from Lansweeper
const getVulnerabilities = async (cursor) => {
  if (cursor == undefined) {
    var pagination = "pagination: { limit: 500, page: FIRST }"
  }
  else {
    var pagination = "pagination: { limit: 500, cursor:\"" + cursor + "\" page: NEXT }"
  }

  var response = axios({
    url: process.env.LANSWEEPER_API_URL,
    method: 'post',
    headers: {
      Authorization: 'Token ' + process.env.LANSWEEPER_API_TOKEN
    },
    data: {
      query: `
      {
        site(id: "`+ process.env.LANSWEEPER_SITE_ID + `") {
          vulnerabilities(
            `+ pagination + `
            filters: {
              conditions: [
                { operator: EQUAL, path: "severity", value: "Critical" }
              
              ]
            }
          ) {
            total
            pagination {
              limit
              current
              next
              page
            }
            items {
              cve
              riskScore
              severity
              assetKeys
              references {
                url
                tags
              }
              isActive
            }
          }
        }
      }
      `
    }
  })
  return response;
}

//download all assets from Lansweeper
const getAssets = async (cursor) => {
  if (cursor == undefined) {
    var assetPagination = "assetPagination: { limit: 500, page: FIRST }"
  }
  else {
    var assetPagination = "assetPagination: { limit: 500, cursor:\"" + cursor + "\" page: NEXT }"
  }

  var response = await axios({
    url: process.env.LANSWEEPER_API_URL,
    method: 'post',
    headers: {
      Authorization: 'Token ' + process.env.LANSWEEPER_API_TOKEN
    },
    data: {
      query: `
      query getAssetResources {
        site(id: "`+ process.env.LANSWEEPER_SITE_ID + `")  {
          assetResources(
            `+ assetPagination + `
            fields: [
              "assetBasicInfo.name"
              "assetBasicInfo.type"
              "assetBasicInfo.ipAddress"
            ]
          ) {
            total
            pagination {
              limit
              current
              next
              page
            }
            items
          }
        }
      }
      `
    }
  })
  //console.log(response)
  return response;
}

//populate vulnerability data with asset datails (vulnerability data contains assetKeys only)
const enrichCVEdatawithAssets = () => {
  for (var i in vulnerabilities) {
    var c = 0
    vulnerabilities[i].assetData = []
    for (var j in vulnerabilities[i].assetKeys) {
      vulnerabilities[i].assetData.push(assets.find(a => a.key === vulnerabilities[i].assetKeys[j]));
    }
  }
}

//build rich text Jira Issue description
const buildJiraIssueDescription = (body) => {
  var assetList = [];
  for (var i in body.assetKeys) {
    var assetData = assets.find(a => a.key === body.assetKeys[i])
    var asset = {
      "type": "listItem",
      "content": [
        {
          "type": "paragraph",
          "content": [
            {
              "type": "text",
              "text": assetData.assetBasicInfo.name,
              "marks": [
                {
                  "type": "link",
                  "attrs": {
                    "href": "https://app.lansweeper.com/api-demo-data-site/asset/" + body.assetKeys[i]
                  }
                }
              ]
            }
          ]
        }
      ]
    }
    assetList.push(asset);
  }

  var output = {
    "version": 1,
    "type": "doc",
    "content": [
      {
        "type": "paragraph",
        "content": [
          {
            "type": "text",
            "text": "Remediate the vulnerability "
          },
          {
            "type": "text",
            "text": body.cve,
            "marks": [
              {
                "type": "strong"
              }
            ]
          },
          {
            "type": "text",
            "text": " in assets: "
          }
        ]
      },
      {
        "type": "bulletList",
        "content": assetList
      },
      {
        "type": "paragraph",
        "content": []
      }
    ]
  }
  return output;
}

///main function handling donwloading all assest and vulnerabilites 
async function main() {
  var response
  var page = 1
  //getting assets
  console.log("Loading page: " + page);
  response = await getAssets();
  page++;
  assets = assets.concat(response.data.data.site.assetResources.items);
  while (response.data.data.site.assetResources.pagination.next != null) {
    console.log("Loading page: " + page);
    response = await getAssets(response.data.data.site.assetResources.pagination.next);
    page++;
    assets = assets.concat(response.data.data.site.assetResources.items);
  }
  console.log(assets.length + " assets were downloaded.")
  page = 1
  //getting vulnerabilites 
  console.log("Loading page: " + page);
  response = await getVulnerabilities();
  page++
  vulnerabilities = vulnerabilities.concat(response.data.data.site.vulnerabilities.items);
  /*while (response.data.data.site.vulnerabilities.pagination.next!=null) {
    console.log(response.data.data.site.vulnerabilities.pagination.next)
    console.log("Loading page: "+page);
    response = await getVulnerabilities(response.data.data.site.vulnerabilities.pagination.next);
    page++
    vulnerabilities=vulnerabilities.concat(response.data.data.site.avulnerabilities.items);
  }*/
  console.log(vulnerabilities.length + " vulnerabilitie were downloaded.")
  enrichCVEdatawithAssets()
}

//run the main function
main()
  .then(() => {
    console.log('Script completed successfully.');
  })
  .catch((error) => {
    console.error('An error occurred:', error);
  });

//**********************************************************************************************/
// Server API section

app.use(bodyParser.json())
app.use(bodyParser.urlencoded({ extended: false }))

//provide all vulnerbaility data 
app.get('/cves', (req, res) => {
  res.status(200);
  res.send(JSON.stringify(vulnerabilities));
})

//accpet reqeust for creation of Jira Issue. When Jira Issue is created enrichin the vulnernerability object with connected Jira Issue
app.post('/ticket', (req, res) => {
  if (req.body != "") {
    var body = req.body;
    console.log(body);

    axios({
      url: process.env.ATLASSIAN_URL,
      method: 'post',
      headers: {
        Authorization: 'Basic ' + Buffer.from(process.env.ATLASIAN_EMAIL + ':' + process.env.ATLASIAN_TOKEN).toString('base64'),
        Accept: 'application/json'
      },
      data: {
        "fields": {
          "project": {
            "id": "10001"
          },
          "issuetype": {
            "id": "10008"
          },
          "summary": "Remediate " + body.cve,
          "description": buildJiraIssueDescription(body)
        }
      }
    }).then((result) => {
      res.status(200);
      res.send(result.data);
      var index = vulnerabilities.findIndex(object => {
        return object.cve === body.cve;
      });
      if (index !== -1) {
        vulnerabilities[index].issue = result.data;
      }
      console.log(result.data)
    });
  }
  else {
    res.status(400);
    res.send('Error - Bad Request')
  }
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})